---
layout: post
title: "명품 자바 프로그래밍 개정 4판: 객체의 소멸과 가비지 컬렉션"
date: 2025-11-01 01:38:00 +09:00
last_modified_at: 2025-11-01 01:38:00 +09:00
categories: Code Java Study
sitemap:
  changefreq: daily
  priority: 0.5
---

### 객체 생성과 객체 소멸
---
 자바에서는 객체를 생성하는 new 연산자는 있지만 객체를 소멸시키는 연산자는 없다. 이런 이유로 자바에서는 개발자가 마음대로 객체를 소멸시킬 수 없다.

### 객체 소멸
---
 new 키워드에 이해 생성된 객체 공간을 JVM에 돌려주어 가용 메모리(Available Memory)에 포함시키는 것이다. 다른 객체 지향 언어인 C++ 에서는 delete 키워드를 두고 있으며, delete 키워드가 실행되면 객체가 곧 바로 소멸된다. 그리고 객체가 소멸될 때 소멸자(Destructor) 메소드가 호출되어 객체가 사라질 때 필요한 마무리 작업을 수행하도록 한다.

 * Object 클래스의 finalize 메소드: 자바에서 소멸자와 가장 유사한 기능을 하는 메소드로 가비지 컬렉터에 의해 객체가 메모리에서 완전히 제거되기 직전에 호출되는 메소드이다. 더 자세한 설명은 다음과 같다.
 	* finalize() 메소드: JVM의 영역 밖에서 할당된 관리되지 않은 자원(Unmanaged Resources)을 정리하는 것이다.
	* 치명적인 단점: 가비지 컬렉터 [실행 시점의 불확실성][1], [성능 저하][2], [예외 처리 문제][3], [객체 부활][4]과 같은 단점으로 현대에는 사용이 권고되지 않는다.

### 가비지 컬렉션과 가비지 컬렉터의 차이
---
 가비지 컬렉션과 컬렉터의 차이는 다음과 같다.

 * 가비지 컬렉션: 자바 언어의 런타임 환경에서 수행되는 메모리 관리 과정 또는 행위 그 자체를 의미한다.
 * 가비지 컬렉터: 가비지 컬렉션이라는 행위를 실제로 수행하는 주체, 즉 소프트웨어 에이전트를 의미한다. JVM의 내부에 내장된 서브 시스템 또는 프로그램 모듈로, 메모리에서 가비지 객체를 찾아내고 정리하는 작업을 책임지는 주체이다.

### 가비지
---
 자바 응용 프로그램에서 더 이상 사용되지 않게 된 객체나 배열 메모리로, 참조하는 레퍼런스가 하나도 없는 객체나 배열을 가비지로 판단한다. 가비지의 발생에 대한 예제 코드는 다음과 같다.

```java
package ch4n9;

public class GarbageExample {
	public static void main(String[] args) {
		String a = new String("Good"); // 지점 1
		String b = new String("Bad"); // 지점 2
		String c = new String("Normal"); // 지점 3
		String d, e; // 지점 4
		
		a = null; // 지점 5
		b = c; // 지점 6, c 변수를 참조한다.
		c = null; // 지점 7 c 변수 데이터는 없지만, b는 여전히 c를 참조한다.
	}
}
```

 위 코드를 실행하면 main() 메소드의 지점 4까지 초기 객체가 생성되면 'a', 'b', 'c' 변수는 각각 "Good", "Bad", "Normal" 문자열 데이터를 메모리에 적재한다. 다음으로 지점 7까지 모든 구문을 실행하게 되면, 'a' 변수는 참조가 존재하지 않아 가비지가 발생되지만, 'c' 변수는 'a' 변수와는 달리 'b' 변수에 의한 참조 대상이므로 가비지로 처리되지 않는다.

### 자바의 가비지 컬렉션
---
 가비지는 더 이상 참조되지 않기 때문에, 가비지가 차지하고 있는 메모리 공간은 회수 되어야 한다. 가비지가 많아지면 응용 프로그램에게 할당해줄 수 있는 가용 메모리의 양이 줄어들게 되기 때문이다. 자바 플랫폼은 가용 메모리가 일정 크기 이하로 줄어들면 자동으로 가비지를 회수하여 가용 메모리를 늘리고, 이것을 가비지 컬렉션이라고 부른다. 가비지 컬렉션은 자바 플랫폼에 의해 준비된 [가비지 컬렉션 스레드][5]에 의해 처리된다.

### 가비지 컬렉션 강제 요청
---
 응용 프로그램에서 System 또는 Runtime 객체의 gc() 메소드를 호출하면 가비지 컬렉션을 요청할 수 있으나, 문장을 호출한 즉시 가비지 컬렉터가 작동하는 것은 아니다. 자바 플랫폼이 가비지 컬렉션의 호출 시기를 전적으로 판단하여 적절한 시점에 작동시킨다.

```java
System.gc(); // 가비지 컬렉션을 강제로 요청한다. 호출 즉시 가비지 컬렉터가 작동되는 것은 아니다.
```

 [1]: https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)#%EA%B0%9D%EC%B2%B4_%EC%9D%B4%EB%8F%99_%EA%B8%B0%EB%B2%95 "가비지 컬렉터는 언제 실행되는지 예측할 수 없으므로, 자원 해제가 지연될 수 있다는 점이다."
 [2]: https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)#%EA%B0%9D%EC%B2%B4_%EC%9D%B4%EB%8F%99_%EA%B8%B0%EB%B2%95 "오버라이딩 객체는 가비지 컬렉터가 처리하므로, 일반 객체보다 메모리 회수 속도가 느려진다."
 [3]: https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)#%EA%B0%9D%EC%B2%B4_%EC%9D%B4%EB%8F%99_%EA%B8%B0%EB%B2%95 "실행 중 예외가 발생하더라도, JVM이 무시하고 스택 추적만 출력한 채 종료되며, 다른 객체의 finalize() 메소드 호출을 방해할 수 있다."
 [4]: https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)#%EA%B0%9D%EC%B2%B4_%EC%9D%B4%EB%8F%99_%EA%B8%B0%EB%B2%95 "메소드 내의 객체 자신을 정적 필드와 같이 다시 접근 가능한 곳에 할당하면, 가비지 컬렉터의 회수 대상에서 제외되어 객체가 부활할 수 있다."
 [5]: https://en.wikipedia.org/wiki/Tracing_garbage_collection "특정 루트 객체의 참조 체인으로 도달할 수 있는 객체를 추적하여 할당을 해제해야 하는 객체를 결정하고 나머지는 가비지로 간주하여 수집하는 자동 메모리 관리의 한 형태이다."
